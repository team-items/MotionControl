################################################################################# Copyright (C) 2016 Daniel Honies# See License File for more Information################################################################################import os, sys, inspectsrc_dir = os.path.dirname(inspect.getfile(inspect.currentframe()))arch_dir = '../lib/x64' if sys.maxsize > 2**32 else '../lib/x86'sys.path.insert(0, os.path.abspath(os.path.join(src_dir, arch_dir)))sys.path.insert(0, "../lib")import Leap, thread, timefrom Leap import CircleGesture, KeyTapGesture, ScreenTapGesture, SwipeGesturefrom Client import *import timeimport mathclass SampleListener(Leap.Listener):    finger_names = ['Thumb', 'Index', 'Middle', 'Ring', 'Pinky']    bone_names = ['Metacarpal', 'Proximal', 'Intermediate', 'Distal']    state_names = ['STATE_INVALID', 'STATE_START', 'STATE_UPDATE', 'STATE_END']    client = Client('192.168.0.224',62626)    def on_init(self, controller):        print "Leap Motion Initialized"    def on_connect(self, controller):        print "Leap Motion Connected"        # Enable gestures        controller.enable_gesture(Leap.Gesture.TYPE_CIRCLE);        controller.enable_gesture(Leap.Gesture.TYPE_KEY_TAP);        controller.enable_gesture(Leap.Gesture.TYPE_SCREEN_TAP);        controller.enable_gesture(Leap.Gesture.TYPE_SWIPE);    def on_disconnect(self, controller):        # Note: not dispatched when running in a debugger.        print "Disconnected"    def on_exit(self, controller):        print "Exited"    def on_frame(self, controller):        # Get the most recent frame and report some basic information        frame = controller.frame()        time.sleep(0.05)        #print "Frame id: %d, timestamp: %d, hands: %d, fingers: %d, tools: %d, gestures: %d" % (         #     frame.id, frame.timestamp, len(frame.hands), len(frame.fingers), len(frame.tools), len(frame.gestures()))        # Get hands        if (frame.hands.is_empty):            self.client.control_motor(0, 0)        else:            hands = frame.hands            hand = hands[0]            handType = "Left hand" if hand.is_left else "Right hand"            position = hand.palm_position            (left, right) = self.calculateSpeed(position)            self.client.control_motor(left, right)        if not (frame.hands.is_empty and frame.gestures().is_empty):            print ""    def state_string(self, state):        if state == Leap.Gesture.STATE_START:            return "STATE_START"        if state == Leap.Gesture.STATE_UPDATE:            return "STATE_UPDATE"        if state == Leap.Gesture.STATE_STOP:            return "STATE_STOP"        if state == Leap.Gesture.STATE_INVALID:            return "STATE_INVALID"        def calculateSpeed(self,position):        x = position[0]        y = position[2]        y = int(y/350*100)        absY = -abs(y)        x = int(x/350*100)        left = absY+(absY/1000*x)        right = absY-(absY/1000*x)        if y > 0:            temp = left            left = -right            right = -temp        print(x)        print(y)        print(left)        print(right)        return (left, right)def main():    # Create a sample listener and controller    listener = SampleListener()    controller = Leap.Controller()    # Have the sample listener receive events from the controller    controller.add_listener(listener)    # Keep this process running until Enter is pressed    print "Press Enter to quit..."    try:        sys.stdin.readline()    except KeyboardInterrupt:        pass    finally:        # Remove the sample listener when done        controller.remove_listener(listener)if __name__ == "__main__":    main()